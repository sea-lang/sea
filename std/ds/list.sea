use std/io

/**
 * A simple dynamic array implementation.
 *
 * Use <make_list> for instantiation.
 *
 * Params:
 *  bump: f32     - How much to multiply the length by when the list needs to grow.
 *  esize: size_t - The size of each element in the array. Do not mutate this!
 *  len: u32      - The current length of the array. Do not mutate this!
 *  cap: u32      - The maximum length of the array. Do not mutate this!
 *  array: ^^void -
 *    Pointer to the first element of the array. Do not make other
 *    pointers to this since it may move from <realloc> calls when the
 *    array needs to grow.
**/
rec List(bump: f32, esize: size_t, len: u32, cap: u32, array: ^^void)

//TODO: Replace element_size with sizeof(T) implicitly. Generic types aren't replaced as identifiers in the prototype impl so we can't do this quite yet.
/**
 * Creates an empty <List>.
 *
 * Args:
 *  initial_cap: u32     - The initial maximum size of the array. Must be `> 0`.
 *  element_size: size_t - The size of each element, i.e, `sizeof(String)`.
 *  bump: f32            - How much to multiply `cap` by when the length exceeds it. `2` is a good default.
**/
fun make_list(initial_cap: u32, element_size: size_t, bump: f32): List {
	var array: ^void = malloc(element_size * initial_cap)
	ret new List(bump, element_size, 0, initial_cap, array)
}

/// Gets the element in <'list> at <'index>, panics if <'index> is out of range.
/// **Pointers returned by this may move after calling <list_grow> or
/// <list_append>.**
fun list_get(list: ^List, index: int): ^void {
	if index > list^.len or index < 0 -> panic("Invalid index")

	ret list^.array[index]
}

/// Grows <'list> to the given <'new_cap>.
fun list_grow(list: ^List, new_cap: u32): bool {
	if list^.cap >= new_cap -> ret false

	var p: ^void = realloc(list^.array, new_cap * list^.esize)
	if p == nil -> ret false

	list^.cap = new_cap
	list^.array = p
	ret true
}

/// Frees the given <'list>.
fun free_list(list: ^List) -> free(list^.array)

/// Appends <'it> to <'list>, growing if needed.
fun list_append(list: ^List, it: ^void) {
	if list^.len + 1 > list^.cap -> list_grow(list, (list^.cap * list^.bump) as u32)

	list^.array[list^.len] = it
	list^.len = list^.len + 1
}

/// Pops the latest element in <'list> and returns it, panics if `<'list>.len == 0`
fun list_pop(list: ^List): ^void {
	if list^.len == 0 -> panic("Cannot pop empty list")

	list^.len = list^.len - 1

	ret list^.array[list^.len]
}

/// Set the element in <'list> at <'index> to <'it>, panics if <'index> is out of range.
fun list_set(list: ^List, index: u32, it: ^void) {
	if index > list^.len or index < 0 -> panic("Invalid index")

	list^.array[index] = it
}
